<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/05/22/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%95%99%E7%A8%8B/"/>
    <url>/2023/05/22/%E5%8D%9A%E5%AE%A2%E6%9B%B4%E6%96%B0%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/09/14/%E5%8D%8E%E4%B8%BA/"/>
    <url>/2022/09/14/%E5%8D%8E%E4%B8%BA/</url>
    
    <content type="html"><![CDATA[<hr><p>title: 华为笔试总结<br>date: 2022-09-14 18:49:21<br>categories: </p><ul><li>面试<br>tags:</li><li>java</li><li>笔试<br>​—</li></ul><h1 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h1><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs inform7">一共m条命，n个跳板,从0跳到n+1<br><br>状态矩阵  dp<span class="hljs-comment">[n+2]</span><span class="hljs-comment">[m]</span><br><br>初始条件<br>dp<span class="hljs-comment">[0]</span><span class="hljs-comment">[m]</span> = 1;<br><br><br>//陷阱跳板放到Hashset中<br>特殊处理前面2个<br>是陷阱<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[m]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[m+1]</span> + dp<span class="hljs-comment">[i-2]</span><span class="hljs-comment">[m+1]</span> + dp<span class="hljs-comment">[i-3]</span><span class="hljs-comment">[m+1]</span>；<br>不是陷阱<br>dp<span class="hljs-comment">[i]</span><span class="hljs-comment">[m]</span> = dp<span class="hljs-comment">[i-1]</span><span class="hljs-comment">[m]</span> + dp<span class="hljs-comment">[i-2]</span><span class="hljs-comment">[m]</span> + dp<span class="hljs-comment">[i-3]</span><span class="hljs-comment">[m]</span>；<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>秒杀学习笔记</title>
    <link href="/2022/07/26/%E7%A7%92%E6%9D%80%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/07/26/%E7%A7%92%E6%9D%80%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="单机秒杀"><a href="#单机秒杀" class="headerlink" title="单机秒杀"></a>单机秒杀</h1><h2 id="情况一"><a href="#情况一" class="headerlink" title="情况一"></a>情况一</h2><p>最简单的查询更新操作，不涉及各种锁，会出现超卖情况。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>首先清空订单表</p><p>新建线程池</p><p>运行200个线程模拟并发请求，</p><p>每个线程的步骤：</p><ul><li>查询商品剩余数量</li><li>如果大于0，商品数量减1，</li><li>创建订单，新建订单记录。</li></ul><p>秒杀成功添加记录到订单表，商品数量减1,</p><p>会出现超卖现象</p><h2 id="情况二"><a href="#情况二" class="headerlink" title="情况二"></a>情况二</h2><p>事务中加锁</p><h3 id="锁释放和事务提交的顺序问题"><a href="#锁释放和事务提交的顺序问题" class="headerlink" title="锁释放和事务提交的顺序问题"></a><a href="https://www.cnblogs.com/xiohao/p/13996619.html">锁释放和事务提交的顺序问题</a></h3><p>面对高并发是锁的实现要使用aop 实现，锁不能加在方法中，因为事务一般是方法结束后提交，而锁在finally 方法中提交，从而会出现锁已经解锁而事务还没来得及提交，下个锁获得到的数据就不对。</p><p>会出现事务没有提交之前，锁已经释放，导致出现超卖1现象。</p><h2 id="情况三"><a href="#情况三" class="headerlink" title="情况三"></a>情况三</h2><p>使用自定义切面AOP，实现锁上移，事务提交后释放锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Servicelock</span><br><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">startSeckilAopLock</span><span class="hljs-params">(<span class="hljs-type">long</span> seckillId, <span class="hljs-type">long</span> userId)</span> &#123;<br><span class="hljs-comment">//来自码云码友&lt;马丁的早晨&gt;的建议 使用AOP + 锁实现</span><br><span class="hljs-type">String</span> <span class="hljs-variable">nativeSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT number FROM seckill WHERE seckill_id=?&quot;</span>;<br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span>  dynamicQuery.nativeQueryObject(nativeSql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;seckillId&#125;);<br><span class="hljs-type">Long</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span>  ((Number) object).longValue();<br><span class="hljs-keyword">if</span>(number&gt;<span class="hljs-number">0</span>)&#123;<br>nativeSql = <span class="hljs-string">&quot;UPDATE seckill  SET number=number-1 WHERE seckill_id=?&quot;</span>;<br>dynamicQuery.nativeExecuteUpdate(nativeSql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;seckillId&#125;);<br><span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">killed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();<br>killed.setSeckillId(seckillId);<br>killed.setUserId(userId);<br>killed.setState(Short.parseShort(number+<span class="hljs-string">&quot;&quot;</span>));<br>killed.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));<br>dynamicQuery.save(killed);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-keyword">return</span> Result.error(SeckillStatEnum.END);<br>&#125;<br><span class="hljs-keyword">return</span> Result.ok(SeckillStatEnum.SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="情况四"><a href="#情况四" class="headerlink" title="情况四"></a>情况四</h2><p>使用了select…for update的方式，这样就通过数据库实现了悲观锁，会对查询的数据记录加锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查询加锁</span><br><span class="hljs-type">String</span> <span class="hljs-variable">nativeSql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT number FROM seckill WHERE seckill_id=? FOR UPDATE&quot;</span>;<br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span>  dynamicQuery.nativeQueryObject(nativeSql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;seckillId&#125;);<br><span class="hljs-type">Long</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span>  ((Number) object).longValue();<br><br><span class="hljs-comment">//数量大于0，更新数据</span><br><span class="hljs-keyword">if</span>(number&gt;<span class="hljs-number">0</span>)&#123;nativeSql = <span class="hljs-string">&quot;UPDATE seckill  SET number=number-1 WHERE seckill_id=?&quot;</span>;<br>dynamicQuery.nativeExecuteUpdate(nativeSql, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;seckillId&#125;);<br><span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">killed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuccessKilled</span>();<br>killed.setSeckillId(seckillId);<br>killed.setUserId(userId);<br>killed.setState((<span class="hljs-type">short</span>)<span class="hljs-number">0</span>);<br>killed.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timestamp</span>(System.currentTimeMillis()));<br>dynamicQuery.save(killed);<br><span class="hljs-keyword">return</span> Result.ok(SeckillStatEnum.SUCCESS);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="情况五"><a href="#情况五" class="headerlink" title="情况五"></a>情况五</h2><p>基于数据库悲观锁实现，更新加锁并判断剩余数量。</p><h2 id="情况六"><a href="#情况六" class="headerlink" title="情况六"></a>情况六</h2><p>基于数据库乐观锁实现，先查询商品版本号，然后根据版本号更新，判断更新数量。少量用户抢购的时候会出现 <strong>少买</strong> 的情况。</p><h2 id="情况七"><a href="#情况七" class="headerlink" title="情况七"></a>情况七</h2><p>进程内队列 LinkedBlockingQueue 实现，同步消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Component</span><br><span class="hljs-comment">//新建线程对于阻塞队列进行循环读取</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">LOGGER</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TaskRunner.class);<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ISeckillService seckillService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments <span class="hljs-keyword">var</span>)</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LOGGER.info(<span class="hljs-string">&quot;提醒队列启动成功&quot;</span>);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//进程内队列</span><br>                    <span class="hljs-type">SuccessKilled</span> <span class="hljs-variable">kill</span> <span class="hljs-operator">=</span> SeckillQueue.getSkillQueue().consume();<br>                    <span class="hljs-keyword">if</span>(kill!=<span class="hljs-literal">null</span>)&#123;<br>                        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span><br>                                seckillService.startSeckilAopLock(kill.getSeckillId(), kill.getUserId());<br>                        <span class="hljs-keyword">if</span>(result.equals(Result.ok(SeckillStatEnum.SUCCESS)))&#123;<br>                            LOGGER.info(<span class="hljs-string">&quot;用户:&#123;&#125;&#123;&#125;&quot;</span>,kill.getUserId(),<span class="hljs-string">&quot;秒杀成功&quot;</span>);<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="情况八"><a href="#情况八" class="headerlink" title="情况八"></a>情况八</h2><p>基于高性能队列 Disruptor实现，同步消费，</p><h1 id="分布式秒杀"><a href="#分布式秒杀" class="headerlink" title="分布式秒杀"></a>分布式秒杀</h1><h2 id="1-Redis-分布式锁"><a href="#1-Redis-分布式锁" class="headerlink" title="1 Redis 分布式锁"></a>1 Redis 分布式锁</h2><p>​    使用redis进行加锁，跟单机加锁一样，会由于锁和事物执行顺序问题，会出现超卖的情况(建议锁上移)。</p>]]></content>
    
    
    <categories>
      
      <category>秒杀项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
      <tag>并发情况</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节一面总结</title>
    <link href="/2022/07/25/%E5%AD%97%E8%8A%821%E9%9D%A2/"/>
    <url>/2022/07/25/%E5%AD%97%E8%8A%821%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><h1 id="1-线程和进程的区别"><a href="#1-线程和进程的区别" class="headerlink" title="1 线程和进程的区别"></a>1 线程和进程的区别</h1><ol><li><p><strong>进程 是操作系统资源分配的最小单位。</strong> <strong>线程</strong>（英语：thread）<strong>是<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>能够进行运算<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6">调度</a>的最小单位</strong></p></li><li><p>进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。</p><p>线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。</p></li><li><p>线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以通信的方式（IPC)进行。</p><p>进程间通信方式：</p><ul><li> 管道</li><li> 消息队列：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。</li><li> 共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。</li><li> 信号量： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</li><li> 套接字</li><li> 信号</li></ul></li><li><p>多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另外一个进程造成影响，因为进程有自己独立的地址空间。</p></li></ol><h1 id="2-死锁的原理"><a href="#2-死锁的原理" class="headerlink" title="2 死锁的原理"></a>2 死锁的原理</h1><p>多个线程/进程在抢占CPU执行权的时候出现了互相等待的状态。</p><h2 id="四个条件"><a href="#四个条件" class="headerlink" title="四个条件"></a>四个条件</h2><p>这四个条件是死锁产生的必要条件，只要发生死锁，一定存在这四个条件</p><p>互斥条件 ：一个资源每次只能被一个进程/线程使用</p><p>请求保持条件：一个进程在申请新的资源的同时保持对原有资源的占有（只有这样才是动态申请，动态分配）；</p><p>循环等待：资源申请者不能强行地从资源占有者手中夺取资源，资源只能由占有者自愿释放；</p><p>不可抢占：若干进程之间形成一种头尾相连的循环等待资源。</p><h1 id="3-url中输入HTTPS后的全流程"><a href="#3-url中输入HTTPS后的全流程" class="headerlink" title="3 url中输入HTTPS后的全流程"></a>3 url中输入HTTPS后的全流程</h1><ol><li><p>解析URL</p><p>检查这些请求是HTTPS还是HTTP，如果是HTTPS的话则使用HTTPS协议进行访问</p></li><li><p>查找IP地址</p><p>首先检查本地缓存中是否存在该域名，如果存在则直接使用缓存中的IP地址进行访问。</p><p>如果不存在，检查域名是否在本地的Hosts文件中，如果找到直接返回域名对应的IP。</p><p>向DNS服务器发送一个域名查询请求，然后就执行DNS查询过程，最终返回域名对应的IP地址。</p></li><li><p>建立连接</p><ul><li>当浏览器得到了目标服务器的 IP 地址，以及 URL 中给出来端口号（http 协议默认端口号是 80， https 默认端口号是 443），它会调用系统库函数 socket ，请求一个 TCP流套接字。进行网络数据的传输。</li><li>连接建立之后，则根据HTTP协议进行数据交换，资源通常是 HTML 文件，也可能是 PDF，图片，或者其他类型的内容。</li></ul></li><li><p>浏览器获得资源文件后，HTML，css，js等文件则根据自身内核的机制，进行页面渲染，然后呈现给用户。</p></li><li><p>浏览器发送连接请求，附上自己支持的加密算法</p></li><li><p>服务器接收到客户端请求，想浏览器发送对应的CA证书，证书包含非堆成加密的公钥以及证书签名。</p></li><li><p>浏览器判断证书是否合法，并生成随机会话密钥，使用公钥加密随机会话密钥后发送给服务器</p></li><li><p>服务器采用私钥解密随机会话密钥</p></li></ol><h1 id="4-cookie和session的区别"><a href="#4-cookie和session的区别" class="headerlink" title="4 cookie和session的区别"></a>4 cookie和session的区别</h1><p>cookie数据保存在<strong>客户端</strong>，session数据保存在<strong>服务器端</strong>。</p><p>Cookie的工作原理：</p><p>（1）浏览器端第一次发送请求到服务器端<br>（2）服务器端创建Cookie，该Cookie中包含用户的信息，然后将该Cookie发送到浏览器端<br>（3）浏览器端再次访问服务器端时会携带服务器端创建的Cookie<br>（4）服务器端通过Cookie中携带的数据区分不同的用户</p><p><img src="https://img-blog.csdnimg.cn/6a2001cb8aaa4cb99a588b13904a7d2d.png#pic_center" alt="img"></p><p>Session的工作原理：</p><p>（1）浏览器端第一次发送请求到服务器端，服务器端创建一个Session，同时会创建一个特殊的Cookie（name为JSESSIONID的固定值，value为session对象的ID），然后将该Cookie发送至浏览器端<br>（2）浏览器端发送第N（N&gt;1）次请求到服务器端,浏览器端访问服务器端时就会携带该name为JSESSIONID的Cookie对象<br>（3）服务器端根据name为JSESSIONID的Cookie的value(sessionId),去查询Session对象，从而区分不同用户。<br>name为JSESSIONID的Cookie不存在（关闭或更换浏览器），返回1中重新去创建Session与特殊的Cookie<br>name为JSESSIONID的Cookie存在，根据value中的SessionId去寻找session对象<br>value为SessionId不存在<strong>（Session对象默认存活30分钟）</strong>，返回1中重新去创建Session与特殊的Cookie<br>value为SessionId存在，返回session对象</p><p><img src="https://img-blog.csdnimg.cn/8d1f669c00e346d7a5c5e0332b3dbd94.png#pic_center" alt="在这里插入图片描述"></p><p>区别：</p><p>cookie数据保存在客户端，session数据保存在服务端。</p><p>session<br>简单的说，当你登陆一个网站的时候，如果web服务器端使用的是session，那么所有的数据都保存在服务器上，客户端每次请求服务器的时候会发送当前会话sessionid，服务器根据当前sessionid判断相应的用户数据标志，以确定用户是否登陆或具有某种权限。由于数据是存储在服务器上面，所以你不能伪造。</p><p>cookie<br>sessionid是服务器和客户端连接时候随机分配的，如果浏览器使用的是cookie，那么所有数据都保存在浏览器端，比如你登陆以后，服务器设置了cookie用户名，那么当你再次请求服务器的时候，浏览器会将用户名一块发送给服务器，这些变量有一定的特殊标记。服务器会解释为cookie变量，所以只要不关闭浏览器，那么cookie变量一直是有效的，所以能够保证长时间不掉线。</p><h1 id="5-MYSQL的索引"><a href="#5-MYSQL的索引" class="headerlink" title="5 MYSQL的索引"></a>5 MYSQL的索引</h1><p>索引是存储引擎用于提高数据库表的访问速度的一种<strong>数据结构</strong>。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li><strong>加快数据查找的速度</strong> </li><li>为用来<a href="">排序</a>或者是分组的字段添加索引，可以加快分组和<a href="">排序</a>的速度 </li><li>加快表与表之间的连接 </li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>建立索引需要<strong>占用物理空间</strong> </li><li>会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行<strong>动态维护索引</strong>，导致增删改时间变长 </li></ul><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><p>数据是存储在磁盘上的，查询数据时，如果没有索引，会加载所有的数据到内存，依次进行检索，读取磁盘次数较多。有了索引，就不需要加载所有数据，因为B+树的高度一般在2-4层，最多只需要读取2-4次磁盘，查询速度大大提升。</p><h3 id="建立索引的条件："><a href="#建立索引的条件：" class="headerlink" title="建立索引的条件："></a>建立索引的条件：</h3><ol><li>经常用于查询的字段 </li><li>经常用于连接的字段建立索引，可以加快连接的速度 </li><li>经常需要<a href="">排序</a>的字段建立索引，因为索引已经排好序，可以加快<a href="">排序</a>查询速度 </li></ol><h3 id="什么情况下不建索引？"><a href="#什么情况下不建索引？" class="headerlink" title="什么情况下不建索引？"></a>什么情况下不建索引？</h3><ol><li><code>where</code>条件中用不到的字段不适合建立索引 </li><li>表记录较少 </li><li>需要经常增删改 </li><li><strong>参与列计算</strong>的列不适合建索引 </li><li><strong>区分度不高</strong>的字段不适合建立索引，如性别等 </li></ol><h1 id="6-并列索引"><a href="#6-并列索引" class="headerlink" title="6 并列索引"></a>6 并列索引</h1><p>ABC</p><p>查询AC只能部分命中,索引的部分命中</p><h3 id="什么是最左匹配原则？"><a href="#什么是最左匹配原则？" class="headerlink" title="什么是最左匹配原则？"></a>什么是最左匹配原则？</h3><p>如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询(<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>)就会停止匹配，后面的字段不会用到索引。</p><p>对<code>(a,b,c)</code>建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。</p><p>对<code>(a,b,c,d)</code>建立索引，查询条件为<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，那么a、b和c三个字段能用到索引，而d无法使用索引。因为遇到了范围查询。</p><p>如下图，对(a, b) 建立索引，a 在索引树中是全局有序的，而 b 是全局无序，局部有序（当a相等时，会根据b进行<a href="">排序</a>）。直接执行<code>b = 2</code>这种查询条件无法使用索引。</p><p><img src="https://uploadfiles.nowcoder.com/files/20211030/8683776_1635580314321/%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80.png" alt="最左前缀"></p><p>当a的值确定的时候，b是有序的。例如<code>a = 1</code>时，b值为1，2是有序的状态。当<code>a = 2</code>时候，b的值为1，4也是有序状态。 当执行<code>a = 1 and b = 2</code>时a和b字段能用到索引。而执行<code>a &gt; 1 and b = 2</code>时，a字段能用到索引，b字段用不到索引。因为a的值此时是一个范围，不是固定的，在这个范围内b值不是有序的，因此b字段无法使用索引。</p><h1 id="7-抽象类和接口的区别"><a href="#7-抽象类和接口的区别" class="headerlink" title="7 抽象类和接口的区别"></a>7 抽象类和接口的区别</h1><h1 id="8-抽象类和接口分别在什么场景下使用"><a href="#8-抽象类和接口分别在什么场景下使用" class="headerlink" title="8 抽象类和接口分别在什么场景下使用"></a>8 抽象类和接口分别在什么场景下使用</h1><p>使用抽象类的情况：</p><ul><li>需要为一些类提供公共的实现代码时，应优先考虑抽象类</li><li>定义某个领域的固有属性</li><li>既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</li></ul><p>使用接口:</p><ul><li>约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现</li><li>实现类需要具备很多不同的功能，但各个功能之间可能没有任何联系。</li><li>使用接口的引用调用具体实现类中实现的方法（多态）</li></ul><h1 id="9-JVM垃圾回收机制、算法"><a href="#9-JVM垃圾回收机制、算法" class="headerlink" title="9 JVM垃圾回收机制、算法"></a>9 JVM垃圾回收机制、算法</h1><p>垃圾收集器：Serial收集器</p><p>算法：</p><ul><li>标记清除算法: 标记要回收的对象，标记完成后统一回收所有被标记的对象。效率问题、空间问题</li><li>复制算法：将内存分为两部分，每次使用一部分，使用完之后将存活对象拷贝到另一块内存当中，再将所有内存全部清除。</li><li>标记-整理算法：标记过程仍然与“标记-清除”算法⼀样，但后续步骤不是直接对可回收对象回收，⽽是让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存 。</li><li>分代收集算法：⽐如在新⽣代中，每次收集都会有⼤量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。⽽⽼年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分<br>配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集  </li></ul><h1 id="10-JAVA中线程、进程同步方式"><a href="#10-JAVA中线程、进程同步方式" class="headerlink" title="10 JAVA中线程、进程同步方式"></a>10 JAVA中线程、进程同步方式</h1><h1 id="11-JAVA类的加载过程"><a href="#11-JAVA类的加载过程" class="headerlink" title="11 JAVA类的加载过程"></a>11 JAVA类的加载过程</h1><ol><li>加载 </li><li>验证 </li><li>准备 </li><li>解析   </li><li>初始化 </li><li>使用 </li><li>卸载</li></ol><h1 id="12-Linux中的内存模型"><a href="#12-Linux中的内存模型" class="headerlink" title="12.Linux中的内存模型"></a>12.Linux中的内存模型</h1><p>内存管理分为连续分配管理以及非连续分配管理两种</p><p>连续分配管理 ：块式管理。</p><p>非连续分配管理：页式管理、段式管理以及段页式管理.</p><p>在分页式内存管理当中，由于存在虚拟内存，存在</p><ol><li>虚拟地址到物理地址的转换要快。</li><li>解决虚拟地址空间⼤，⻚表也会很⼤的问题  </li></ol><p>为了解决虚拟地址到物理地址的转换速度，操作系统在 ⻚表⽅案 基础之上引⼊了 快表 来加速虚拟地<br>址到物理地址的转换。其中的内容是⻚表的⼀部分或者全部内容。作为⻚表的 Cache，它的作⽤与⻚表相似，但是提⾼了访问速率。由于采⽤⻚表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问⼀次⾼速缓冲存储器，⼀次主存，这样可加速查找并提⾼指令执⾏速度。  </p><ol><li>根据虚拟地址中的⻚号查快表；</li><li>如果该⻚在快表中，直接从快表中读取相应的物理地址；</li><li>如果该⻚不在快表中，就访问内存中的⻚表，再从⻚表中得到物理地址，同时将⻚表中的该映射<br>表项添加到快表中；</li><li>当快表填满后，⼜要登记新⻚时，就按照⼀定的淘汰策略淘汰掉快表中的⼀个⻚。  </li></ol><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个数n如23121;给定一组数字a如[2 4 9]求由a中元素组成的小于n的最大数</p><h2 id="代码解析思路"><a href="#代码解析思路" class="headerlink" title="代码解析思路"></a>代码解析思路</h2><p>该题使用到的算法主要是贪心、回溯以及二分，首先将nums数组进行排序方便进行二分查找，之后将给定数字n分解成一个列表，注意最高位在列表的最后一位，需要从前往后尽心寻找。</p><p>首先判断能取的最大数跟N的位数是否相同，不同直接取数组中的最大值即可。<br>注意如果出现前面取跟n一样的数，而后面出现没有数可以取的情况需要回溯减小前面的数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.byte_mianshi;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Nmin</span> &#123;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">static</span>  <span class="hljs-type">boolean</span> <span class="hljs-variable">over</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">resolve</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span>[] data)</span>&#123;<br>        Arrays.sort(data);<br>        List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n_copy</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (n_copy &gt;<span class="hljs-number">0</span>)&#123;<br>            tmp = n_copy % <span class="hljs-number">10</span>;<br>            n_copy = n_copy / <span class="hljs-number">10</span>;<br>            list.add(tmp);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数据打印开始&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d: list) &#123;<br>            System.out.println(d);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数据打印开始&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;数组打印开始&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> d : data)&#123;<br>            System.out.println(d);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;数组打印完毕&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;数据大小：&quot;</span> + list.size());<br><br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">minData</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> d: list) &#123;<br>            minData = minData * <span class="hljs-number">10</span> + data[<span class="hljs-number">0</span>];<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;最小值&quot;</span>+minData);<br>        <span class="hljs-keyword">if</span>(minData &gt;= n)&#123;<br>            <span class="hljs-comment">//只能取比n少一位</span><br>            dfs(data,list,n,list.size()-<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">true</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dfs(data,list,n,list.size()-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">false</span>);<br>        &#125;<br><br>        System.out.println(ret);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data  可选数组数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> list  分解后的n值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> index  当前正在选择的位数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ans    已经选择的数组成的值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> flag   是否可以无脑选择最大数的标志位</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span>[] data,List&lt;Integer&gt; list,<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> index,<span class="hljs-type">int</span> ans,<span class="hljs-type">boolean</span> flag)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> list.size();<br>        <span class="hljs-keyword">if</span>(over == <span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//选择完毕</span><br>            <span class="hljs-keyword">if</span>(ans &lt; n)&#123;<br>                ret = Math.max(ret,ans);<br>                over = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> ;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(flag == <span class="hljs-literal">false</span>)&#123;<br>            <span class="hljs-comment">//找到最大的不大于list.get(index)的坐标</span><br>            <span class="hljs-type">int</span>  <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> find(list.get(index) , data);<br>            <span class="hljs-comment">//当前所有的数都比需要小于的数大，说明前面的数取大了，直接返回</span><br>            <span class="hljs-keyword">if</span>( f &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> f;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>                    ans = ans * <span class="hljs-number">10</span> + data[i];<br>                    <span class="hljs-keyword">if</span>(data[i] &lt; list.get(index))&#123;<br>                        flag = <span class="hljs-literal">true</span>;<br>                        dfs(data,list,n,index-<span class="hljs-number">1</span>,ans,flag);<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">//相等的情况</span><br>                        dfs(data,list,n,index-<span class="hljs-number">1</span>,ans,flag);<br>                    &#125;<br>                    ans = (ans - data[i])/<span class="hljs-number">10</span>;<br>                &#125;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//说明前面有数字比n对应的数字小，可以一直取最大值</span><br>            ans = ans * <span class="hljs-number">10</span> + data[data.length-<span class="hljs-number">1</span>];<br>            dfs(data,list,n,index-<span class="hljs-number">1</span>,ans,flag);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 找到不大于min的第一个序列号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> min</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data  查找的数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   数组中第一个小于等于min的序号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">int</span> min,<span class="hljs-type">int</span>[] data)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> data.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + ((right - left)&gt;&gt;<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>( data[mid] &lt;= min)&#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( right &lt;<span class="hljs-number">0</span> )&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> right;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试案例"><a href="#测试案例" class="headerlink" title="测试案例"></a>测试案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NminTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Nmin</span> <span class="hljs-variable">nmin</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Nmin</span>();<br>        <span class="hljs-type">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;;<br>        nmin.resolve(<span class="hljs-number">2333</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br>        nmin.resolve(<span class="hljs-number">233332</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br>        nmin.resolve(<span class="hljs-number">500</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">4</span>,<span class="hljs-number">9</span>&#125;);<br>        nmin.resolve(<span class="hljs-number">5612</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;);<br>        nmin.resolve(<span class="hljs-number">5416</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">2</span>&#125;);<br>        nmin.resolve(<span class="hljs-number">123434</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">8</span>&#125;);<br>        nmin.resolve(<span class="hljs-number">32</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">2332</span><br><span class="hljs-number">233323</span><br><span class="hljs-number">499</span><br><span class="hljs-number">5588</span><br><span class="hljs-number">5288</span><br><span class="hljs-number">118888</span><br><span class="hljs-number">23</span><br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百度一面总结</title>
    <link href="/2022/07/25/%E7%99%BE%E5%BA%A61%E9%9D%A2/"/>
    <url>/2022/07/25/%E7%99%BE%E5%BA%A61%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="单例模式的写法"><a href="#单例模式的写法" class="headerlink" title="单例模式的写法"></a>单例模式的写法</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a><strong>饿汉式</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Main</span> <span class="hljs-variable">main</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>  Main <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> main;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Main main;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Main <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(main == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> main;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="双重检测的单例模式"><a href="#双重检测的单例模式" class="headerlink" title="双重检测的单例模式"></a>双重检测的单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Main main;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Main</span><span class="hljs-params">()</span>&#123;<br>    &#125;<br>    <span class="hljs-keyword">public</span>  Main <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(main == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(Main.class)&#123;<br>                <span class="hljs-keyword">if</span>(main == <span class="hljs-literal">null</span>)&#123;<br>                    main = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>();<br>                &#125;<br>            &#125;<br>&#125;<br>        <span class="hljs-keyword">return</span> main;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表 - 力扣（LeetCode）</a></p><p>给定一个单链表 <code>L</code> 的头节点 <code>head</code> ，单链表 <code>L</code> 表示为：</p><p><img src="C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220725185720810.png" alt="image-20220725185720810"></p><p>请将其重新排列后变为：</p><p><img src="C:\Users\jinhu\AppData\Roaming\Typora\typora-user-images\image-20220725185702653.png" alt="image-20220725185702653"></p><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。原地交换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reorderList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> findMid(head);<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">relist</span> <span class="hljs-operator">=</span> reverseList(mid.next);<br>            mid.next = <span class="hljs-literal">null</span>;<br><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> head;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">recopy</span> <span class="hljs-operator">=</span> relist;<br>            <span class="hljs-comment">//合并两个链表</span><br>            <span class="hljs-keyword">while</span>( recopy != <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span>  <span class="hljs-operator">=</span> copy.next;<br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp1</span> <span class="hljs-operator">=</span> recopy.next;<br>                copy.next = recopy;<br>                recopy.next = tmp;<br>                copy = tmp;<br>                recopy = tmp1;<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//快慢指针返回列表的中点</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">findMid</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br><br>        <span class="hljs-keyword">while</span>(fast != <span class="hljs-literal">null</span> &amp;&amp; fast.next != <span class="hljs-literal">null</span>)&#123;<br>            slow = slow.next;<br>            fast = fast.next.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">//反转链表</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(head.next == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>            head.next.next = head;<br>            head.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试</tag>
      
      <tag>算法</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javaIO学习</title>
    <link href="/2022/07/25/javaIO%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/07/25/javaIO%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="IO学习"><a href="#IO学习" class="headerlink" title="IO学习"></a>IO学习</h1><span id="more"></span><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Java 中的 BIO、NIO和 AIO 理解为是 <strong>Java 语言对操作系统的各种 IO 模型的封装</strong>。程序员在使用这些 API 的时候，不需要<strong>关心操作系统层面的知识</strong>，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。</p><h3 id="1-1-IO基础知识"><a href="#1-1-IO基础知识" class="headerlink" title="1.1 IO基础知识"></a>1.1 IO基础知识</h3><p><strong>IO</strong> (Input/Output,输入/输出)即<strong>数据的读取(接收)或写入(发送)操作</strong>，通常用户进程中的一个<strong>完整IO</strong>分为两阶段:<strong>用户进程空间&lt;–&gt;内核空间</strong>、<strong>内核空间&lt;–&gt;设备空间</strong>(磁盘、网络等)。IO有内存IO、网络IO和磁盘IO三种,通常我们说的IO指的是后两者。</p><p>网络I/O就是通过网络进行数据的拉取和输出。</p><p>磁盘I/O主要是对磁盘进行读写工作。</p><blockquote><p>比如你打开浏览器，访问腾讯首页，浏览器这个程序就需要通过网络IO获取腾讯的网页。浏览器首先会发送数据给腾讯服务器，告诉它我想要首页的HTML，这个动作是往外发数据，叫Output，腾讯服务器把网页发过来，这个动作是从外面接收数据，叫Input。所以，通常，程序完成IO操作会有Input和Output两个数据流。当然也有只用一个的情况，比如，从磁盘读取文件到内存，就只有Input操作，反过来，把数据写到磁盘文件里，就只是一个Output操作。</p></blockquote><blockquote><p>流是什么？可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进存，Output Stream就是数据从内存流到外面去。<strong>对于浏览网页来说，浏览器和腾讯服务器之间至少需要建立两根水管</strong>，才可以既能发数据，又能收数据。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200229183652880.png" alt="在这里插入图片描述"></p><p>LINUX中<strong>进程无法直接操作I/O设备</strong>，其必须通过<strong>系统调用</strong>请求kernel来协助完成<strong>I/O动作</strong>；内核会为每个I/O设备维护一个缓冲区。</p><p>对于一个输入操作来说，进程IO系统调用后，内核会<strong>先看缓冲区中有没有相应的缓存数据</strong>，<strong>没有</strong>的话再到<strong>设备中读取</strong>,因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。</p><p>所以，对于一个网络输入操作通常包括两个不同阶段:</p><ul><li>等待网络数据到达网卡→读取到内核缓冲区，数据准备好;</li><li>从内核缓冲区复制数据到进程空间</li></ul><p>由于CPU和内存的速度远远高于外设的速度。所以在<strong>IO编程</strong>中，就存在<strong>速度严重不匹配</strong>的问题。</p><h4 id="1-1-1-用户空间与内核空间"><a href="#1-1-1-用户空间与内核空间" class="headerlink" title="1.1.1 用户空间与内核空间"></a>1.1.1 用户空间与内核空间</h4><p>内核空间是内核代码运行的地方，<br>用户空间是用户程序代码运行的地方。</p><p>当进程运行在内核空间时就处于内核态，当进程运行在用户空间时就处于用户态。</p><h4 id="1-1-2-同步异步"><a href="#1-1-2-同步异步" class="headerlink" title="1.1.2 同步异步"></a>1.1.2 同步异步</h4><p><strong>定义</strong></p><ul><li><strong>同步</strong> ：两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在<code>A-&gt;B</code>事件模型中，你需要先完成 A 才能执行B。 再换句话说，<strong>同步调用中被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</strong></li><li><strong>异步</strong>： 两个异步的<strong>任务是完全独立的</strong>，一方的执行不需要等待另外一方的执行。再换句话说，异步调用中<strong>一调用就返回结果不需要等待结果返回</strong>，当<strong>结果返回的时候通过回调函数</strong>或者<strong>其他方式</strong>拿着结果再做相关事情，</li></ul><p><strong>另一篇文章中的定义</strong></p><ul><li>同步请求：A调用B，B的处理是同步的，在处理完之前他不会通知A，只有处理完之后才会明确的通知A。</li><li>异步请求：A调用B，B的处理是异步的，B在接到请求后先告诉A我已经接到请求了，然后异步去处理，处理完之后通过回调等方式再通知A。</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p><strong>同步异步主要用于描述被调用者B的返回方式，立即返回就是异步，执行完毕返回就是同步。</strong></p><p>同步和异步最大的区别就是被调用方的执行方式和返回时机。</p><p><strong>同步指的是被调用方做完事情之后再返回，</strong></p><p>异步指的是被调用方<strong>先返回</strong>，然后再<strong>做事情</strong>，做完之后再想办法<strong>通知调用方</strong>。</p><h4 id="1-1-3-阻塞非阻塞"><a href="#1-1-3-阻塞非阻塞" class="headerlink" title="1.1.3 阻塞非阻塞"></a>1.1.3 阻塞非阻塞</h4><ul><li><strong>阻塞：</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</li><li><strong>非阻塞：</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</li></ul><p><strong>另一篇文章中的定义</strong></p><ul><li>阻塞请求，A调用B，A一直等着B的返回，别的事情什么也不干。</li><li>非阻塞请求，A调用B，A不用一直等着B的返回，先去忙别的事情了。</li></ul><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>主要在被调用者返回前的时间内调用者A的行为。</p><p><strong>阻塞和非阻塞</strong>最大的<strong>区别</strong>就是在<strong>被调用方返回结果之前的这段时间内</strong>，<strong>调用方是否一直等待</strong>。</p><p><strong>阻塞指的是调用方一直等待，别的事情什么都不做。</strong></p><p><strong>非阻塞指的是调用方先去忙别的事情。</strong></p><h3 id="1-2-五种IO模型"><a href="#1-2-五种IO模型" class="headerlink" title="1.2   五种IO模型"></a>1.2   五种IO模型</h3><h4 id="1-2-1-阻塞IO模型"><a href="#1-2-1-阻塞IO模型" class="headerlink" title="1.2.1 阻塞IO模型"></a>1.2.1 阻塞IO模型</h4><p>当<strong>用户线程发出IO请求</strong>之后，内核会去查看<strong>数据是否就绪</strong>，如果没有就绪就会<strong>等待数据就绪</strong>，而<strong>用户线程</strong>就会处于<strong>阻塞状态</strong>，用户线程交出CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除block状态。</p><p><img src="https://img-blog.csdnimg.cn/20200229200534398.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3NTk2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>进程发起IO系统调用后,进程被阻塞,转到内核空间处理,整个IO处理完毕后返回进程。操作成功则进程获取到数据</strong></p><p><img src="https://img-blog.csdnimg.cn/20200229200805541.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3NTk2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="1-2-2-非阻塞IO模型"><a href="#1-2-2-非阻塞IO模型" class="headerlink" title="1.2.2 非阻塞IO模型"></a>1.2.2 非阻塞IO模型</h4><p>进程发起IO<strong>系统调用</strong>后,如果内核缓冲区没有数据,<strong>需要到IO设备中读取，进程返回一个错误</strong>而不会被阻塞;进程发起IO系统调用后，如果内核<strong>缓冲区有数据</strong>，内核就会把<strong>数据返回给进程</strong>。</p><p>对于上面的阻塞IO模型来说，内核数据没准备好需要进程阻塞的时候，就返回一个错误,以使得进程不被阻塞。</p><p><img src="https://img-blog.csdnimg.cn/20200229201122343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3NTk2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。</strong></p><h4 id="1-2-3-IO复用模型"><a href="#1-2-3-IO复用模型" class="headerlink" title="1.2.3 IO复用模型"></a>1.2.3 IO复用模型</h4><p><strong>多个的进程的IO可以注册到一个复用器(select)上，然后用一个进程调用该select,，select会监听所有注册进来的IO。</strong></p><p>如果<strong>select监听的IO在内核缓冲区都没有可读数据</strong>，select调用进程会被<strong>阻塞</strong>；而当<strong>任一IO在内核缓冲区中有可数据时</strong>，<strong>select调用就会返回</strong>；而后<strong>select调用进程可以自己或通知另外的进程</strong>(注册进程)来<strong>再次发起读取IO，读取内核中准备好的数据</strong>。</p><p><img src="https://img-blog.csdnimg.cn/20200229201544406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3NTk2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>典型应用: select、 poll、 epoll三种方案，nginx都可以选择使用这三个方案</strong></p><p>select, poll和epoll</p><ul><li>**Select:**注册IO、阻塞扫描，监听的IO最大连接数不能多于FD_ SIZE（1024）;</li><li>**Poll:**原理和Select相似，没有数量限制，但IO数量大扫描线性性能下降;</li><li>**Epoll :**事件驱动不阻塞, mmap实现内核与用户空间的消息传递，数量很大，Linux2.6后内核支持</li></ul><p>例如：<br>1）select/poll<br>小明去火车站买票，委托黄牛,黄牛三天内买到票,然后打便所有人要买票人的电话找到小明，小明去火车站交钱领票。<br>耗费:往返车站2次,路上2小时,黄牛手续费100元，等待通知3小时</p><p>2)epoll<br>小明去火车站买票，委托黄牛,黄牛买到后即通知小明去领，然后小明去火车站交钱领票。<br>耗费:往返车站2次，路上2小时,黄牛手续费100元，无需打电话</p><h4 id="1-2-4-信号驱动IO模型"><a href="#1-2-4-信号驱动IO模型" class="headerlink" title="1.2.4 信号驱动IO模型"></a>1.2.4 信号驱动IO模型</h4><p>在信号驱动IO模型中，当用户线程发起一个<strong>IO请求操作</strong>，会给对应的socket<strong>注册一个信号函数</strong>，然后用户线程会继续执行，当内核数<strong>据就绪时会发送一个信号给用户线程</strong>，用户线程接收到信号之后，便在<strong>信号函数中调用IO读写操作来进行实际的IO请求操作</strong>。这个一般用于UDP中，<strong>对TCP套接口几乎是没用的，原因是该信号产生得过于频繁</strong>，并且该信号的出现并没有告诉我们发生了什么事情。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/mQlO20PgUDLJyNAPpmHXFWjrXZ2uXvSe3jGJekgJ1X4kjia7AABicVEAvNVXDQBI4o2pLW3b9EiaibiavFnTBABicUfw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据</p><h4 id="1-2-5-异步IO模型"><a href="#1-2-5-异步IO模型" class="headerlink" title="1.2.5 异步IO模型"></a>1.2.5 异步IO模型</h4><p>当<strong>进程发起一个IO操作</strong>,<strong>进程返回(不阻塞),<strong>但也不能返回结果;<strong>内核把整个IO处理完</strong>后，会</strong>通知进程</strong>结果。如果IO操作成功则进程直接获取到数据。</p><p><img src="https://img-blog.csdnimg.cn/20200229202723330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3NTk2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>例如：<br>小明去火车站买票，给售票员留下电话,有票后，售票员电话遇知小明并快递送票上门。<br>耗费:往返车站1次，路上1小时,免黄牛费100元,无需打电话</p><p><strong>注意：</strong><br>此模型和前面模型最大的区别是：<strong>前4个都是阻塞的</strong>，因为<strong>需要自己把用户准备好的数据，放在我的用户空间，而全异步都帮我们做好了。</strong><br>用户线程完全不需要关心实际的整个IO操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。它是最理想的模型。</p><h4 id="1-2-6-区别"><a href="#1-2-6-区别" class="headerlink" title="1.2.6 区别"></a>1.2.6 区别</h4><p>同步I/O引起进程阻塞，直到I/O操作完成<br>异步I/O不会引起进程阻塞</p><p>阻塞式I/O， 非阻塞I/O， I/O复用由于都导致了请求进程阻塞，所以均属于同步I/O。</p><p><img src="https://img-blog.csdnimg.cn/20200229203120783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc3NTk2Mw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-BIO-同步阻塞IO"><a href="#1-BIO-同步阻塞IO" class="headerlink" title="1 BIO 同步阻塞IO"></a>1 BIO 同步阻塞IO</h2><p>同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。</p><h3 id="1-1-传统BIO"><a href="#1-1-传统BIO" class="headerlink" title="1.1 传统BIO"></a>1.1 传统BIO</h3><p><strong>被调用者执行完才返回</strong>(同步)，<strong>调用者在返回前一直阻塞</strong>(阻塞)。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2.png" alt="传统BIO通信模型图"></p><p>采用 <strong>BIO 通信模型</strong> 的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接。我们一般通过在<code>while(true)</code> 循环中服务端会调用 <code>accept()</code> 方法等待接收客户端的连接的方式监听请求，请求一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成， 不过可以通过多线程来支持多个客户端的连接，如上图所示。</p><p>如果要让 <strong>BIO 通信模型</strong> 能够同时处理多个客户端请求，就必须使用多线程（主要原因是<code>socket.accept()</code>、<code>socket.read()</code>、<code>socket.write()</code> 涉及的三个主要函数都是同步阻塞的），也就是说它在接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 <strong>一请求一应答通信模型</strong> 。我们可以设想一下如果这个连接不做任何事情的话就会造成不必要的线程开销，不过可以通过 <strong>线程池机制</strong> 改善，线程池还可以让线程的创建和回收成本相对较低。使用<code>FixedThreadPool</code> 可以有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N(客户端请求数量):M(处理客户端请求的线程数量)的伪异步I/O模型（N 可以远远大于 M），下面一节”伪异步 BIO”中会详细介绍到。</p><h3 id="1-2-伪异步IO"><a href="#1-2-伪异步IO" class="headerlink" title="1.2 伪异步IO"></a>1.2 伪异步IO</h3><p>为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，后来有人对它的线程模型进行了优化一一一后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M：线程池最大线程数N的比例关系，其中M可以远远大于N.通过线程池可以灵活地调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/3.png" alt="伪异步IO模型图"></p><p>采用线程池和任务队列可以实现一种叫做伪异步的 I/O 通信框架，它的模型图如上图所示。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。</p><p>伪异步I/O通信框架采用了线程池实现，因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层仍然是同步阻塞的BIO模型，因此无法从根本上解决问题。</p><h3 id="1-3-代码示例"><a href="#1-3-代码示例" class="headerlink" title="1.3 代码示例"></a>1.3 代码示例</h3><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 闪电侠</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年10月14日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>:客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOClient</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// TODO 创建多个线程，模拟多个客户端连接服务端</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">3333</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            socket.getOutputStream().write((<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;: hello world&quot;</span>).getBytes());<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>          &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      &#125;<br>    &#125;).start();<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 闪电侠</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018年10月14日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: 服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IOServer</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// TODO 服务端处理客户端连接请求</span><br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(<span class="hljs-number">3333</span>);<br><br>    <span class="hljs-comment">// 接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-comment">// 阻塞方法获取新的连接</span><br>          <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br><br>          <span class="hljs-comment">// 每一个新的连接都创建一个线程，负责读取数据</span><br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-type">int</span> len;<br>              <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>              <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>              <span class="hljs-comment">// 按字节流方式读取数据</span><br>              <span class="hljs-keyword">while</span> ((len = inputStream.read(data)) != -<span class="hljs-number">1</span>) &#123;<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data, <span class="hljs-number">0</span>, len));<br>              &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            &#125;<br>          &#125;).start();<br><br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        &#125;<br><br>      &#125;<br>    &#125;).start();<br><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/BIO,NIO,AIO%E6%80%BB%E7%BB%93?id=_14-%E6%80%BB%E7%BB%93">1.4 总结</a></h3><p>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</p><h2 id="2-NIO-（New-IO）"><a href="#2-NIO-（New-IO）" class="headerlink" title="2 NIO （New IO）"></a>2 NIO （New IO）</h2><h3 id="2-1-NIO简介"><a href="#2-1-NIO简介" class="headerlink" title="2.1 NIO简介"></a>2.1 NIO简介</h3><p>NIO是一种<strong>同步非阻塞的I/O模型</strong>，在Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。</p><p><strong>被调用者先执行后返回，同步；</strong></p><p><strong>调用者在调用后、返回前不等待。非阻塞</strong></p><p>NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> <strong>两种不同的套接字通道实现,<strong>两种通道都</strong>支持阻塞和非阻塞</strong>两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于<strong>高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</strong>。</p><h3 id="2-2-NIO特性-NIO与IO的区别"><a href="#2-2-NIO特性-NIO与IO的区别" class="headerlink" title="2.2 NIO特性 NIO与IO的区别"></a>2.2 NIO特性 NIO与IO的区别</h3><h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p><strong>IO流是阻塞的，NIO流是不阻塞的。</strong></p><p>Java NIO使我们可以进行非阻塞IO操作。比如说，<strong>单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据</strong>。写数据也是一样的。另外，非阻塞写也是如此。一个线程<strong>请求写入一些数据到某通道，但不需要等待它完全写入</strong>，这个线程同时可以去做别的事情。</p><p>Java IO的各种流是阻塞的。这意味着，<strong>当一个线程调用 <code>read()</code> 或 <code>write()</code> 时，该线程被阻塞，直到有一些数据被读取，或数据完全写入</strong>。该线程在此期间不能再干任何事情了</p><h4 id="缓冲区Buffer"><a href="#缓冲区Buffer" class="headerlink" title="缓冲区Buffer"></a>缓冲区Buffer</h4><p><strong>IO 面向流(Stream oriented)，而 NIO 面向缓冲区(Buffer oriented)。</strong></p><p><strong>Buffer是一个对象</strong>，它包含一些<strong>要写入或者要读出的数据</strong>。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。<strong>在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中</strong>。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。</p><p>在NIO厍中，<strong>所有数据都是用缓冲区处理的</strong>。在读取数据时，它是直接读到缓冲区中的; 在写入数据时，写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。</p><p><strong>最常用的缓冲区是 ByteBuffer,一个 ByteBuffer 提供了一组功能用于操作 byte 数组。</strong>除了ByteBuffer,还有其他的一些缓冲区，事实上，每一种Java基本类型（除了Boolean类型）都对应有一种缓冲区。</p><h4 id="通道Channel"><a href="#通道Channel" class="headerlink" title="通道Channel"></a>通道Channel</h4><p>NIO 通过Channel（通道） 进行读写。</p><p>通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。</p><h4 id="选择器Selector"><a href="#选择器Selector" class="headerlink" title="选择器Selector"></a>选择器Selector</h4><p>NIO有选择器，而IO没有。</p><p>选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Slector.png" alt="一个单线程中Selector维护3个Channel的示意图"></p><h3 id="2-3-NIO读数据和写数据的方式"><a href="#2-3-NIO读数据和写数据的方式" class="headerlink" title="2.3 NIO读数据和写数据的方式"></a>2.3 NIO读数据和写数据的方式</h3><p>通常来说NIO中的所有IO都是从 Channel（通道） 开始的。</p><ul><li>从通道进行数据读取 ：创建一个缓冲区，然后请求通道读取数据。</li><li>从通道进行数据写入 ：创建一个缓冲区，填充数据，并要求通道写入数据。</li></ul><p>数据读取和写入操作图示：</p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/NIO%E8%AF%BB%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E5%BC%8F.png" alt="NIO读写数据的方式"></p><h3 id="2-4-NIO核心组件"><a href="#2-4-NIO核心组件" class="headerlink" title="2.4 NIO核心组件"></a>2.4 NIO核心组件</h3><p>NIO 包含下面几个核心的组件：</p><ul><li>Channel(通道)</li><li>Buffer(缓冲区)</li><li>Selector(选择器)</li></ul><h3 id="2-5-代码示例"><a href="#2-5-代码示例" class="headerlink" title="2.5 代码示例"></a>2.5 代码示例</h3><p>客户端代码不变。</p><h4 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 闪电侠</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2019年2月21日</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span>: NIO 改造后的服务端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NIOServer</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 1. serverSelector负责轮询是否有新的连接，服务端监测到新的连接之后，不再创建一个新的线程，</span><br>    <span class="hljs-comment">// 而是直接将新连接绑定到clientSelector上，这样就不用 IO 模型中 1w 个 while 循环在死等</span><br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">serverSelector</span> <span class="hljs-operator">=</span> Selector.open();<br>    <span class="hljs-comment">// 2. clientSelector负责轮询连接是否有数据可读</span><br>    <span class="hljs-type">Selector</span> <span class="hljs-variable">clientSelector</span> <span class="hljs-operator">=</span> Selector.open();<br><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 对应IO编程中服务端启动</span><br>        <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">listenerChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>        listenerChannel.socket().bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">3333</span>));<br>        listenerChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>        listenerChannel.register(serverSelector, SelectionKey.OP_ACCEPT);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>          <span class="hljs-comment">// 监测是否有新的连接，这里的1指的是阻塞的时间为 1ms</span><br>          <span class="hljs-keyword">if</span> (serverSelector.select(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            Set&lt;SelectionKey&gt; set = serverSelector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();<br><br>            <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>              <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br><br>              <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">// (1) 每来一个新连接，不需要创建一个线程，而是直接注册到clientSelector</span><br>                  <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> ((ServerSocketChannel) key.channel()).accept();<br>                  clientChannel.configureBlocking(<span class="hljs-literal">false</span>);<br>                  clientChannel.register(clientSelector, SelectionKey.OP_READ);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  keyIterator.remove();<br>                &#125;<br>              &#125;<br><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>      &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>          <span class="hljs-comment">// (2) 批量轮询是否有哪些连接有数据可读，这里的1指的是阻塞的时间为 1ms</span><br>          <span class="hljs-keyword">if</span> (clientSelector.select(<span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            Set&lt;SelectionKey&gt; set = clientSelector.selectedKeys();<br>            Iterator&lt;SelectionKey&gt; keyIterator = set.iterator();<br><br>            <span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>              <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyIterator.next();<br><br>              <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientChannel</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();<br>                  <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">byteBuffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                  <span class="hljs-comment">// (3) 面向 Buffer</span><br>                  clientChannel.read(byteBuffer);<br>                  byteBuffer.flip();<br>                  System.out.println(<br>                      Charset.defaultCharset().newDecoder().decode(byteBuffer).toString());<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                  keyIterator.remove();<br>                  key.interestOps(SelectionKey.OP_READ);<br>                &#125;<br>              &#125;<br><br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException ignored) &#123;<br>      &#125;<br>    &#125;).start();<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么大家都不愿意用 JDK 原生 NIO 进行开发呢？从上面的代码中大家都可以看出来，是真的难用！除了编程复杂、编程模型难之外，它还有以下让人诟病的问题：</p><ul><li>JDK 的 NIO 底层由 epoll 实现，该实现饱受诟病的空轮询 bug 会导致 cpu 飙升 100%</li><li>项目庞大之后，自行实现的 NIO 很容易出现各类 bug，维护成本较高，上面这一坨代码我都不能保证没有 bug</li></ul><p>Netty 的出现很大程度上改善了 JDK 原生 NIO 所存在的一些让人难以忍受的问题。</p><h2 id="3-AIO-Asynchronous-I-O"><a href="#3-AIO-Asynchronous-I-O" class="headerlink" title="3. AIO (Asynchronous I/O)"></a><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basis/BIO,NIO,AIO%E6%80%BB%E7%BB%93?id=_3-aio-asynchronous-io">3. AIO (Asynchronous I/O)</a></h2><p>AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。</p><p>AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。（除了 AIO 其他的 IO 类型都是同步的，这一点可以从底层IO线程模型解释，推荐一篇文章：<a href="https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect">《漫话：如何给女朋友解释什么是Linux的五种IO模型？》</a> ）</p><p>查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/23/hello-world/"/>
    <url>/2022/07/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
